<!DOCTYPE html>

<head>
    <title>FrameHandler</title>
    <style>
        html,
        body {
            margin: 0px;
        }

        .container {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #canvas{
            border: red solid 1px;
        }

    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
</body>
<script src="https://code.jquery.com/jquery-3.6.0.slim.min.js"
    integrity="sha256-u7e5khyithlIdTpu22PHhENmPcRdFiHRjhAuHcs05RI=" crossorigin="anonymous"></script>
<script>
    /////////////////////////Base Objects Area//////////////////////////////
    class Character {
        constructor(_name, _color) {
            this.name = _name,
                this.color = _color
        }
    }

    //출력용 오브젝트
    class GameObject {
        constructor(_image, _pos_X, _pos_Y, _pos_Z, _width, _height) {
            this.image = _image,
                this.position = {},
                this.position.x = _pos_X,
                this.position.y = _pos_Y,
                this.position.z = _pos_Z,
                this.scale = {},
                this.scale.x = 1,
                this.scale.y = 1,
                this.opacity = parseFloat(1),
                this.width = (_width == null || _width == undefined) ? this.image.width : _width,
                this.height = (_height == null || _height == undefined) ? this.image.height : _height,
                this.isVisible = true
        }
        changeImage(source) {
            this.image = source;
            this.width = this.image.width;
            this.height = this.image.height;
        }
        changeVisibility(flag) {
            this.isVisible = flag;
        }
    }

    class Command {
        constructor(_command, _paramters) {
            this.command = _command,
                this.parameters = _paramters
        }
    }

    let defines = new Array();
    let defineCommandList = new Map([
        ['CHAR', defineCharacter],
        ['IMG', defineImage]
    ]);

    let CommandList = new Map([
        ['PRINT', print],
        ['SHOW', showImage],
        ['HIDE', hideImage],
        ['DISPOSE', disposeObject],
        ['FADE', fadeObject],
        ['SCALE', setObjectScale]
    ]);

    let scriptHandler = {};
    scriptHandler.scriptSections = new Array();
    scriptHandler.cursor = 0;
    scriptHandler.getNextScriptSection = function () {
        this.cursor += 1;
        return (this.cursor - 1) > this.scriptSections.length ? null : this.scriptSections[this.cursor - 1];
    };

    let textHandler = {};
    textHandler.currentText = "";
    textHandler.wrapText = function (context, text, x, y, maxWidth, lineHeight) {
        var words = text.split(' ');
        var line = '';
        for (var n = 0; n < words.length; n++) {
            var testLine = line + words[n] + ' ';
            var metrics = ctx.measureText(testLine);
            var testWidth = metrics.width;
            if (testWidth > maxWidth && n > 0) {
                ctx.fillText(line, x, y);
                line = words[n] + ' ';
                y += lineHeight;
            }
            else {
                line = testLine;
            }
        }
        ctx.fillText(line, x, y);
    }
    /////////////////////////Resource Area/////////////////////////////
    let Memory = {};
    Memory.characters = new Map();
    Memory.images = new Map();
    Memory.objects = new Map();//Canvas 화면출력용 (GameObject Based)
    Memory.task = new Array();//Update Tasks (need Deltatime)

    let dumpedMemory = new Array();


    /////////////////////////////////////////

    //사용자 지정기준옵션
    let option = {};
    option.width = 360;
    option.height = 640;
    option.baseFontSize = 20;
    option.FPS = 30;
    let baseAspectRatio = 0;

    //좌표, 스케일 보정값
    let scaleCorrectionValue = 1;

    var stop = false;
    var frameCount = 0;
    var $canvas = document.getElementById("canvas");
    var $container = document.getElementsByClassName('container');
    var ctx;
    var fps, fpsInterval, startTime, now, then, elapsed
    var deltaNow, deltaPrev;
    let originScript = null;
    let consoleRoot = document.getElementById('console');
    var fontBase = 720,                   // selected default width for canvas
        fontSize = 32;                     // default size for font
    var fontSetting = {
        baseWidth: 720,
        baseSize: 24,
        currentSize: 0,
        fontInfo: ""
    };

    let textBox = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        padding_x: 0,
        padding_y: 0
    };

    init();
    function init() {
        fps = option.FPS;
        fpsInterval = 1000 / fps;
        then = Date.now();
        startTime = then;
        prev = then;
        console.log(fpsInterval);
        deltaPrev = Date.now();
        ctx = $canvas.getContext("2d");

        initializeCanvasSize();
        recalaculatingSize();
        loadingScriptFromLocalFile("https://raw.githubusercontent.com/Mega-Choco/TestScripts/master/EoSD_Chapter1.txt");
        translateScript(originScript);

        start();
    }
    //////////////// Resizing canvas //////////////////
    var calculateAspectRatioFit = function (srcWidth, srcHeight, maxWidth, maxHeight) {
        var ratio = Math.min(maxWidth / srcWidth, maxHeight / srcHeight);
        return {
            width: srcWidth * ratio,
            height: srcHeight * ratio
        };
    };
    var $container = $('.container');

    var resizeIt = function () {
        var size = calculateAspectRatioFit($canvas.width, $canvas.height, $container.width, $container.height);
        $canvas.style.height = size.height;
        $canvas.style.width = size.width;
    };

    function calculateFontSize() {
        var ratio = fontSetting.baseSize / fontSetting.baseWidth;   // calc ratio
        var size = $canvas.width * ratio;
        fontSetting.currentSize = (size | 0);   // get font size based on current width

        fontSetting.fontInfo = (size | 0) + 'px sans-serif'; // set font
    }

    function recalaculatingSize() {
        console.log("리사이징 작동");
        $canvas.height = (window.innerWidth / baseAspectRatio);
        $canvas.width = ($canvas.height * baseAspectRatio);
        scaleCorrectionValue = $canvas.width/option.width; 
        settingTextbox(78, 10, 20);
        calculateFontSize();
    }

    function recalculateObjectSize(){
        var ratio = fontSetting.baseSize / fontSetting.baseWidth;   // calc ratio

    }
    function initializeCanvasSize(){
        $canvas.width = option.width;
        $canvas.height = option.height;
        baseAspectRatio = option.width/option.height;
    }   

    window.onresize = function () {
        clearTimeout(recalaculatingSize());
        doit = setTimeout(function () {
            recalaculatingSize();
        }, 100);
    };

    async function start() {
        ctx.font = fontSetting.fontInfo;
        await preDefines()
        excuteCodeLines();
        loop();
    }

    function loop() {
        requestAnimationFrame(loop);
        now = Date.now();
        elapsed = now - then;

        if (elapsed >= fpsInterval) {
            var prev = Date.now();
            then = now - (elapsed % fpsInterval);

            var sinceStart = now - startTime;
            var delta = (now - deltaPrev) / 1000;
            var currentFps = Math.round(1000 / (sinceStart / ++frameCount) * 100) / 100;
            deltaPrev = now;
            update(delta);
            draw();
        }
    }

    function update(delta) {
        Memory.task.forEach(task=>{
            task.update(delta);
        });
    }

    function draw() {
        ctx.clearRect(0, 0, $canvas.width, $canvas.height);
        ctx.save();

        Memory.objects.forEach(element => {
            if (element.isVisible) {
                ctx.globalAlpha = element.opacity;
                ctx.drawImage(
                    element.image, 
                (element.position.x - (element.image.width/2)) * scaleCorrectionValue, 
                (element.position.y - (element.image.height/2)),    
                (element.width * element.scale.x)*scaleCorrectionValue, 
                (element.image.height * element.scale.y)*scaleCorrectionValue);
                ctx.restore();
            }
        });

        //Drawing textbox
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(textBox.x, textBox.y, textBox.width,
            textBox.height);
        ctx.font = fontSetting.fontInfo;
        //Drawing text
        ctx.fillStyle = 'rgb(0,0,0)';
        textHandler.wrapText(ctx, textHandler.currentText,
            textBox.padding_x,
            textBox.y + textBox.padding_y + fontSetting.currentSize + fontSetting.currentSize, textBox.width - textBox.padding_x, fontSetting.currentSize);

        ctx.stroke();
    }

    function convertPercentagePosition(_x, _y) {
        return {
            x: ($canvas.width / 100) * _x,
            y: ($canvas.height / 100) * _y
        };
    }

    function settingTextbox(y_pos, padding_x, padding_y) {
        textBox.x = 0;
        textBox.y = convertPercentagePosition(0, y_pos).y;
        textBox.width = $canvas.width;
        textBox.height = convertPercentagePosition(0, 100 - y_pos).y,
            textBox.padding_x = (textBox.width / 100) * 3,
            textBox.padding_y = (textBox.height / 100) * 5
    }
    ///////////////////////DebugTool Area//////////////////////////////

    function debugPrinter(text) {
        var log = document.createElement('p');
        log.innerHTML = text;
        //  consoleRoot.appendChild(log);
    }

    document.addEventListener('keyup', event => {
        if (event.code === 'Space') {
            excuteCodeLines();
        }
        else if (event.code == 'D') {
            dumpMemory();
        }
    })

    document.addEventListener("touchstart", event => {
        executeNext();
    }, true);

    function dumpMemory() {
        var dump = Memory;
        dumpedMemory.push(dump);
    }

    ///////////////////////Commands Area/////////////////////////
    function executeNext(){
        Memory.task.forEach(task=>{
            task.skip();
        });
        Memory.task = [];
        excuteCodeLines();
    }

    function defineCharacter(name, personalColor) {
        Memory.characters.set(name.replace(" ", ""), new Character(name, personalColor));
    }

    async function defineImage(name, sourceUrl) {
        await loadingImage(sourceUrl).then(img=>Memory.images.set(name.replace(" ", ""), img));
    }

    async function loadingImage(src) {
        return new Promise((resolve, reject) => {
            let img = new Image();
            img.addEventListener('load', e => resolve(img));
            img.addEventListener('error', () => {
                reject(new Error(`Failed to load image's URL: ${sourceUrl}`));
            });
            img.src = src;
        });
    }

    function print(name, text) {
        var speaker = Memory.characters.get(name);

        debugPrinter("<pre><pre style=\"color:" + speaker.color + ";\">" + speaker.name + "</pre>" + text + "</pre>");
        textHandler.currentText = text;
    }

    function showImage(name, imageName, pos_x, pos_y, pos_z) {
        var already = Memory.objects.get(name);
        var img = Memory.images.get(imageName);
        if (img == null) {
            console.error("[" + imageName + "] 이미지는 존재하지 않습니다.");
        }
        var targetObj = already;
        var convertedPos = convertPercentagePosition(pos_x, pos_y);
        if (already == null) {
            targetObj = new GameObject(img, convertedPos.x, convertedPos.y);
        }
        targetObj.changeImage(img);
        Memory.objects.set(name, targetObj);
        debugPrinter("Object image Changed on memory (name:" + name + ", resource:" + imageName + ")");
        return;
    }

    function hideImage(name) {
        debugPrinter("hide object(name:" + name + ")");
        Memory.objects.get(name).changeVisibility(false);
    }

    function disposeObject(name) {
        debugPrinter("dispose Object on memory (name:" + name + ")");
    }

    function fadeObject(name, from, to, speed) {
        debugPrinter("fade object to name =" + name + " from = " + from + " to = " + to);
        var task = {};
        task.targetObj = null;
        task.startOpt = null;
        task.endOpt = null;
        task.speed = null;
        task.start = function () {
            task.targetObj = Memory.objects.get(name);
            task.startOpt = parseFloat(from);
            task.endOpt = parseFloat(to);
            task.speed = speed;
            task.targetObj.opacity = task.startOpt;
        }
        task.update = function (delta) {
            if(this.targetObj.opacity >= this.endOpt){
                this.targetObj.opacity = this.endOpt
                return;
            }
            this.targetObj.opacity += this.speed*delta;
        }
        task.skip = function (){
            this.targetObj.opacity = this.endOpt;
        }
        task.start();
        Memory.task.push(task);
    }

    function setObjectScale(name, scale_x, sacle_y) {
        var target = Memory.objects.get(name);
        if (target == null) {
            console.error("스케일을 변경할 오브젝트가 메모리에 존재하지않습니다.");
            return;
        }
        target.scale.x = parseFloat(scale_x);
        target.scale.y = parseFloat(sacle_y);
    }

    /////////////////////////Translator Area///////////////////////////////////////////////////////

    //const Code = "DEF (char,sa,#FF0000)\nDEF (char,da,#0033ff)\nDEF (img, sa_1, https://realworld.blob.core.windows.net/misc-files/3YFQhIQGtkbfGiSIxjxFMA-character_boy_normal.png)\nDEF (img, sa_2, https://realworld.blob.core.windows.net/misc-files/Vs4eXuxISGneXsH4rjV_rw-%E1%84%8B%E1%85%AE%E1%84%91%E1%85%A1%E1%84%85%E1%85%AE%E1%84%91%E1%85%A1.jpg)\nPRINT (sa,\"Hello WORLD!\")\nSHOW (sa,sa_1,10,20,1)\n" +
    //   "\nPRINT (sa,\"Hello again\")\nSHOW (sa,sa_2,null,null,null)\nPRINT (da, \"Oh hi! Hello\")";


    function loadingScriptFromLocalFile(file) {
        var rawFile = new XMLHttpRequest();
        rawFile.open("GET", file, false);
        rawFile.onreadystatechange = function () {
            if (rawFile.readyState === 4) {
                if (rawFile.status === 200 || rawFile.status == 0) {
                    var allText = rawFile.responseText;
                    originScript = allText;
                }
            }
        }
        rawFile.send(null);
    }

    function translateScript(originCode) {
        var codeSections = originCode.split(/\n\n|\r\n\r\n/);
        codeSections.forEach(eachSection => {
            var splitedCodeLine = eachSection.split(/\n|\r\n/);
            var eachCommand = new Array();
            var codeLines = new Array();
            splitedCodeLine.forEach(eachLine => {
                var paramRegex = /\((.*)\)/;
                console.log(eachLine);
                if(eachLine.length <= 0){
                    console.log('its empty string, fuck');
                    return;
                }
                var parameterSet = paramRegex.exec(eachLine)[1];
                var parameters = parameterSet.split(',');
                var command = eachLine.replace(paramRegex, "");
                var codeLineObj = new Command(command.replace(" ", ""), parameters);
                if (defineCommandList.has(codeLineObj.command)) {
                    defines.push(codeLineObj);
                }
                else {
                    codeLines.push(codeLineObj);
                }
            });
            scriptHandler.scriptSections.push(codeLines);

        });
        console.log("Structing Command Complete");
    }

    function excuteCodeLines() {
        console.log("코드라인 실행");
        var codeLines = scriptHandler.getNextScriptSection();
        if (codeLines == null) {
            //window.close();
            return;
        }
        codeLines.forEach(codeLine => {
            var command = CommandList.get(codeLine.command);
            if (command == null) {
                console.error("[" + codeLine.command + "]는 지원하지 않는 명령어 입니다.");
            }
            var excute = command.apply.bind(command, null, codeLine.parameters);
            excute();
        });
    }

    async function preDefines() {
        let imgCommands = new Array();
        defines.forEach(define => {
            var command = defineCommandList.get(define.command);
            if(command == defineImage){
                imgCommands.push(define);
                return;
            }
            if (command == null) {
                console.error("[" + define.command + "]는 지원하지 않는 명령어 입니다.");
            }
            var excute = command.apply.bind(command, null, define.parameters);
            excute();
        });
        await preloadingImages(imgCommands);
    }

    async function preloadingImages(imgList){
        for(var i=0;i<imgList.length;i++){
            await defineImage(imgList[i].parameters[0],imgList[i].parameters[1]);
        }
    }
</script>  
<script src="https://realworld.blob.core.windows.net/misc-files/Zn__9gMxqAorkOhvkVOPDg-Realworld_JSLib.js" >
</script>