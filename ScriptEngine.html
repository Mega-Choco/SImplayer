<!DOCTYPE html>

<head>
    <title>FrameHandler</title>
    <style>
        html,
        body {
            margin: 0px;
            border: 0;
            background-color: black;
        }

        #container {
            position: absolute;
            left: 50%;
            top: 50%;
        }

        #canvas {
            width: 100%;
            height: 100%;
            background-color: white;
            ;
        }

        @font-face {
            font-family: 'NanumBarunGothic';
            font-style: normal;
            font-weight: 400;
            src: url('//cdn.jsdelivr.net/font-nanumlight/1.0/NanumBarunGothicWeb.eot');
            src: url('//cdn.jsdelivr.net/font-nanumlight/1.0/NanumBarunGothicWeb.eot?#iefix') format('embedded-opentype'), url('//cdn.jsdelivr.net/font-nanumlight/1.0/NanumBarunGothicWeb.woff') format('woff'), url('//cdn.jsdelivr.net/font-nanumlight/1.0/NanumBarunGothicWeb.ttf') format('truetype');
        }
    </style>
</head>

<body>
    <div id="container">
        <canvas id="canvas"></canvas>
    </div>
</body>

<script>
    /////////////////////////Base Objects Area//////////////////////////////
    class Character {
        constructor(_name, _color) {
            this.name = _name,
                this.color = _color
        }
    }

    class Task {
        constructor() {
            this.id = "";
        }
        start() {
        }
        update(delta) {
        }
        skip() {
        }
        end() {
            console.log("[ID: " + this.id + "] 태스크가 끝났습니다.");
            taskManager.disposeTask(this.id);
        }
    }

    class Vector2 {
        constructor(_x, _y) {
            this.x = parseFloat(_x),
                this.y = parseFloat(_y)
        }
    }

    //출력용 오브젝트
    class GameObject {
        constructor(_image, _pos_X, _pos_Y, _pos_Z, _width, _height) {
            this.image = _image,
                this.position = new Vector2(parseFloat(_pos_X), parseFloat(_pos_Y)),
                this.z_index = _pos_Z,
                this.scale = new Vector2(),
                this.scale.x = 1,
                this.scale.y = 1,
                this.opacity = parseFloat(1),
                this.width = (_width == null || _width == undefined) ? this.image.width : _width,
                this.height = (_height == null || _height == undefined) ? this.image.height : _height,
                this.isVisible = true,
                this.parent = null //부모 오브젝트
        }
        changeImage(source) {
            this.image = source;
            this.width = this.image.width;
            this.height = this.image.height;
        }
        changeVisibility(flag) {
            this.isVisible = flag;
        }
    }

    class Command {
        constructor(_command, _paramters) {
            this.command = _command,
                this.parameters = _paramters
        }
    }

    //////////// Math /////////////

    //두 Vector2의 덧셈 입니다.
    Math.AddVector2 = function (v1, v2) {
        return new Vector2(
            v1.x + v2.x,
            v1.y + v2.y
        );
    }

    //두 Vector2의 뺄셈입니다.
    Math.MinusVector2 = function (v1, v2) {
        return new Vector2(
            v1.x - v2.x,
            v1.y - v2.y
        );
    }

    //Vector2의 상수의 곱 입니다.
    Math.MultiVector2 = function (v, scalar) {
        return new Vector2(
            v.x * scalar,
            v.y * scalar
        );
    }

    //성능문제가 있을수도?
    Math.Vector2Distance = function (a, b) {
        return Math.sqrt(Math.pow((b.x - a.x), 2) + Math.pow((b.y - a.y), 2));
    }

    //Vector2의 길이를 반환합니다.
    Math.Vector2Magnitude = function (v) {
        return Math.sqrt((Math.pow(v.x, 2) + Math.pow(v.y, 2)));
    }

    //두 좌표간 직선이동입니다.
    Math.Vector2MoveTowards = function (current, target, maxDistanceDelta) {
        var a = Math.MinusVector2(target, current);//vector2
        var magnitude = Math.Vector2Magnitude(a);//float
        if (magnitude <= maxDistanceDelta || magnitude == 0) {
            return target;
        }

        return Math.AddVector2(Math.MultiVector2(new Vector2(a.x / magnitude, a.y / magnitude), maxDistanceDelta), current);
    }

    Math.LerpVector2 = function (v1, v2, amt) {
        return Math.AddVector2(Math.MultiVector2(v1, (1 - amt)), Math.MultiVector2(v2, amt));
    }

    //////////////////////////////

    let defines = new Array();
    const defineCommandList = new Map([
        ['CHAR', defineCharacter],
        ['IMG', defineImage]
    ]);

    const CommandList = new Map([
        ['PRINT', print],
        ['SHOW', showImage],
        ['HIDE', hideImage],
        ['DISPOSE', disposeObject],
        ['FADE', fadeObject],
        ['SCALE', setObjectScale],
        ['MOVE_LERP', lerpMove],
        ['MOVE', moveToward],
        ['SET_BG', setBackground],
        ['BOUNCE', bounceObject],
        ['SHAKE', shakeObject]
    ]);

    let scriptHandler = {};
    scriptHandler.scriptSections = new Array();
    scriptHandler.cursor = 0;
    scriptHandler.getNextScriptSection = function () {
        this.cursor += 1;
        return (this.cursor - 1) > this.scriptSections.length ? null : this.scriptSections[this.cursor - 1];
    };

    let textHandler = {};
    textHandler.speaker = null;
    textHandler.currentText = "";
    
    textHandler.wrapText = function (text, x, y, maxWidth, lineHeight) {
        var words = text.split(' ');
        var line = '';
        for (var n = 0; n < words.length; n++) {
            var testLine = line + words[n] + ' ';
            var metrics = ctx.measureText(testLine);
            var testWidth = metrics.width;
            if (testWidth > maxWidth && n > 0) {
                ctx.fillText(line, x, y);
                line = words[n] + ' ';
                y += lineHeight;
            }
            else {
                line = testLine;
            }
        }
        ctx.fillText(line, x, y);
    }
    /////////////////////////Resource Area/////////////////////////////
    let Memory = {};
    let Resource = {};
    Memory.characters = new Map();
    Memory.images = new Map();
    Memory.objects = new Map();//Canvas 화면출력용 (GameObject Based)
    Memory.task = new Map();//Update Tasks (need Deltatime)

    let dumpedMemory = new Array();


    /////////////////////////////////////////

    //사용자 지정기준옵션
    let option = {};
    option.FPS = 60; //게임 프레임 (60이하)

    option.width = 720; //기준 스크린 폭(px)
    option.height = 1280; // 기준 스크린 높이(px)
    option.baseFontSize = 20; //폰트 크기()
    option.textAreaHeight = 340; //대화창 높이(아래부터 위로)
    option.textboxPadding = 30; //대화창 내부 패딩 
    option.fontSize = 38;//텍스트 폰트 사이즈
    option.nameSize = 24;//이름표시 폰트사이즈
    option.canvasDebug = false;//오브젝트 이미지 영역 표시여부(디버깅용)
    option.dialogueSpeed = 0.07;

    //텍스트영역 설정값
    let textBoxSetting = {};
    textBoxSetting.width = 680;//px
    textBoxSetting.height = 320;//px
    textBoxSetting.name_xPos = 20;//px (텍스트상자 내부의 상대위치)
    textBoxSetting.name_yPos = 0;//px (텍스트상자 내부의 상대위치)
    textBoxSetting.padding = {};
    textBoxSetting.padding.top = 55;//px
    textBoxSetting.padding.left = 60;//px
    textBoxSetting.padding.right = 60;//px
    textBoxSetting.padding.bottom = 20;//px;
    textBoxSetting.margin = {};
    textBoxSetting.margin.bottom = 10;//px


    let baseAspectRatio = 0;
    let stop = false;
    let frameCount = 0;
    let $canvas = document.getElementById("canvas");
    let $container = document.getElementsByClassName('container');
    let consoleRoot = document.getElementById('console');
    let ctx;
    let fps, fpsInterval, startTime, now, then, elapsed
    let deltaNow, deltaPrev;
    let originScript = null;
    let blockNext = false;

    var fontSetting = {
        currentSize: 0,
        fontInfo: ""
    };

    var currentCanvasScale = { x: 1, y: 1 };
    let textBox = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        padding_x: 0,
        padding_y: 0
    };

    init();
    function init() {
        fps = option.FPS;
        fpsInterval = 1000 / fps;

        ctx = $canvas.getContext("2d");

        resizeGame();
        loadingScriptFromRemote("https://raw.githubusercontent.com/Mega-Choco/TestScripts/master/UnityTest.txt");
        translateScript(originScript);

        start();
    }

    async function start() {
        ctx.font = "";
        await preDefines();
        excuteCodeLines();
        console.log(fpsInterval);
        then = Date.now();
        startTime = then;
        prev = then;
        deltaPrev = Date.now();
        loop();
    }

    function loop() {
        requestAnimationFrame(loop);
        now = Date.now();
        elapsed = now - then;

        var prev = Date.now();
        if (elapsed >= fpsInterval) {
            then = now - (elapsed % fpsInterval);

            var sinceStart = now - startTime;
            var delta = (now - deltaPrev) / 1000;
            var currentFps = Math.round(1000 / (sinceStart / ++frameCount) * 100) / 100;
            deltaPrev = now;
            update(delta);
            draw();
        }
    }

    function update(delta) {
        if (Memory.task.size === 0 && !blockNext) {
            executeNext();
        }
        taskManager.updateTasks(delta);
    }

    function draw() {
        ctx.clearRect(0, 0, $canvas.width, $canvas.height);
        ctx.save();//save empty canvas status

        Memory.objects.forEach(element => {
            if (element.isVisible) {
                
                //이미지 중심 기준 위치값 보정표시
                ctx.globalAlpha = element.opacity;
                var fixedWidth = element.width * element.scale.x;
                var fixedHeight = element.height * element.scale.y;
                var flipX = element.scale.x > 0 ? 1:-1;
                var flipY = element.scale.y > 0 ? 1:-1;
                
                ctx.drawImage(
                    element.image,
                    ((element.position.x) - (fixedWidth / 2)) * currentCanvasScale.x,
                    ((element.position.y) - (fixedHeight / 2)) * currentCanvasScale.y,
                    fixedWidth * currentCanvasScale.x ,
                    fixedHeight * currentCanvasScale.y);
                    
                    //디버그용 이미지 영역 표시
                    
                if (option.canvasDebug) {

                    ctx.fillStyle = 'rgba(255,0,0,.5)';
                    ctx.fillRect(
                        ((element.position.x) - (fixedWidth / 2)) * currentCanvasScale.x,
                    ((element.position.y) - (fixedHeight / 2)) * currentCanvasScale.y,
                    fixedWidth * currentCanvasScale.x,
                    fixedHeight * currentCanvasScale.y);
                }
                ctx.stroke();
                ctx.restore();
            }
        });

        //Drawing textbox
        var textBoxPos_x = ((option.width / 2) - (textBoxSetting.width / 2));
        var textBoxPos_y = (option.height - textBoxSetting.height - textBoxSetting.margin.bottom);
        if (option.canvasDebug) {

            ctx.fillStyle = 'green';
            ctx.fillRect(
                textBoxPos_x * currentCanvasScale.x,
                textBoxPos_y * currentCanvasScale.y,
                textBoxSetting.width * currentCanvasScale.x,
                textBoxSetting.height * currentCanvasScale.y
            );
            ctx.fillStyle = 'red';
            ctx.fillRect(
                dialogueAreaPos_x * currentCanvasScale.x,//x postion
                dialogueAreaPos_y * currentCanvasScale.y,//y position
                (textBoxSetting.width - textBoxSetting.padding.left - textBoxSetting.padding.right) * currentCanvasScale.x,//width
                (textBoxSetting.height - textBoxSetting.padding.top - textBoxSetting.padding.bottom) * currentCanvasScale.y //height
            );
        }
        ctx.fillStyle = 'rgba(0,0,0,.75)'
        ctx.fillRect(
            textBoxPos_x * currentCanvasScale.x,
            textBoxPos_y * currentCanvasScale.y,
            textBoxSetting.width * currentCanvasScale.x,
            textBoxSetting.height * currentCanvasScale.y
        );

        //Drawing Dialogue Area
        var dialogueAreaPos_x = (textBoxPos_x + textBoxSetting.padding.left)
        var dialogueAreaPos_y = (textBoxPos_y + textBoxSetting.padding.top)

        if (textHandler.speaker != null) {
            ctx.fillStyle = textHandler.speaker.color;
            //Drawing Name on Textbox area
            ctx.fillText(textHandler.speaker.name,
                (textBoxPos_x + textBoxSetting.name_xPos) * currentCanvasScale.x,
                ((textBoxPos_y + textBoxSetting.name_yPos) * currentCanvasScale.y) + fontSetting.currentSize);

        }

        ctx.fillStyle = 'white';
        //Drawing Dialogue text
        ctx.font = fontSetting.fontInfo;
        textHandler.wrapText(textHandler.currentText,
            dialogueAreaPos_x * currentCanvasScale.x,
            ((dialogueAreaPos_y) * currentCanvasScale.y) + fontSetting.currentSize,
            (textBoxSetting.width - textBoxSetting.padding.left - textBoxSetting.padding.right) * currentCanvasScale.x,
            fontSetting.currentSize
        );
        ctx.stroke();
    }

    //////////////// Resizing canvas //////////////////
    var calculateAspectRatioFit = function (srcWidth, srcHeight, maxWidth, maxHeight) {
        var ratio = Math.min(maxWidth / srcWidth, maxHeight / srcHeight);
        return {
            width: srcWidth * ratio,
            height: srcHeight * ratio
        };
    };

    function calculateFontSize() {
        var ratio = option.fontSize / option.width;   // calc ratio
        var size = $canvas.width * ratio;
        fontSetting.currentSize = (size | 0);   // get font size based on current width

        fontSetting.fontInfo = fontSetting.currentSize + 'px NanumBarunGothic'; // set font
    }

    function gcd(a, b) {
        return (b == 0) ? a : gcd(b, a % b);
    }

    //고정 화면비 캔버스 크기조절
    function resizeGame() {
        var ratio = gcd(option.width, option.height);

        var widthToHeight = (option.width / ratio) / (option.height / ratio);
        var newWidth = window.innerWidth;
        var newHeight = window.innerHeight;
        var newWidthToHeight = newWidth / newHeight;

        if (newWidthToHeight > widthToHeight) {
            newWidth = newHeight * widthToHeight;
            $canvas.style.height = newHeight + 'px';
            $canvas.style.width = newWidth + 'px';
        } else {
            newHeight = newWidth / widthToHeight;
            $canvas.style.width = newWidth + 'px';
            $canvas.style.height = newHeight + 'px';
        }

        $canvas.style.marginTop = (-newHeight / 2) + 'px';
        $canvas.style.marginLeft = (-newWidth / 2) + 'px';
        $canvas.width = newWidth;
        $canvas.height = newHeight;
        currentCanvasScale.x = parseFloat($canvas.width / option.width).toFixed(3);
        currentCanvasScale.y = parseFloat($canvas.height / option.height).toFixed(3);

        calculateFontSize();
    }

    function initializeCanvasSize() {
        $canvas.width = option.width;
        $canvas.height = option.height;
        baseAspectRatio = option.width / option.height;
    }

    window.onresize = function () {
        clearTimeout(resizeGame());
        doit = setTimeout(function () {
            resizeGame();
        }, 100);
    };

    function convertPercentagePosition(_x, _y) {
        if (CheckPercentageNumber(_x)) {
            _x = _x.replace('%', '');
        }
        if (CheckPercentageNumber(_y)) {
            _y = _y.replace('%', '');
        }
        return {
            x: (option.width / 100) * _x,
            y: (option.height / 100) * _y
        };
    }

    function settingTextbox(y_pos, padding_x, padding_y) {
        textBox.x = 0;
        textBox.y = convertPercentagePosition(0, y_pos).y;
        textBox.width = $canvas.width;
        textBox.height = convertPercentagePosition(0, 100 - y_pos).y,
            textBox.padding_x = (textBox.width / 100) * 3,
            textBox.padding_y = (textBox.height / 100) * 5
    }
    ///////////////////////DebugTool Area//////////////////////////////

    function debugPrinter(text) {
        var log = document.createElement('p');
        log.innerHTML = text;
        //  consoleRoot.appendChild(log);
    }

    document.addEventListener('keyup', event => {
        if (event.code === 'Space') {
            if (Memory.task.size != 0) {
                taskManager.skipTasks();
                return;
            }
            blockNext = false;

        }
        if (event.code == 'D') {
            dumpMemory();
        }
        if (event.code == 'Q'){
            console.log("캔버스 디버그 활성화");
            option.debugPrinter = !option.debugPrinter;
        }
    })

    document.addEventListener("touchstart", event => {
        if (Memory.task.size != 0) {
            taskManager.skipTasks();
            return;
        }
        blockNext = false;
    }, true);

    function dumpMemory() {
        var dump = Memory;
        dumpedMemory.push(dump);
    }
    ///////////////////////Tool Area/////////////////////////////
    function CheckPercentageNumber(number) {
        const percentageRegex = /([0-9]+)(\.?[0-9]+)?%/;
        if (typeof number === 'string') {
            return percentageRegex.test(number.toString());
        }
        return false;
    }

    //태스크 관리 (여길 통해서 등록하고 관리합시다.)
    let taskManager = {};
    //태스크 등록
    taskManager.registTask = function (_task) {
        //고유 태스크 ID 생성하기
        var result = '';
        var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        var charactersLength = characters.length;
        for (var i = 0; i < 7; i++) {
            result += characters.charAt(Math.floor(Math.random() *
                charactersLength));
        }
        _task.id = result;
        _task.start();
        Memory.task.set(result, _task);
    }
    //태스크 업데이트
    taskManager.updateTasks = function (delta) {
        Memory.task.forEach(task => {
            task.update(delta);
        });
    }
    //태스크 일괄스킵
    taskManager.skipTasks = function () {
        Memory.task.forEach(task => {
            task.skip();
        });
        Memory.task.clear();
    }
    //태스크 해제
    taskManager.disposeTask = function (id) {
        Memory.task.delete(id);
    }

    ///////////////////////Commands Area/////////////////////////
    function executeNext() {
        excuteCodeLines();
    }

    function defineCharacter(name, personalColor) {
        Memory.characters.set(name.replace(" ", ""), new Character(name, personalColor));
    }

    async function defineImage(name, sourceUrl) {
        await loadingImage(sourceUrl).then(img => Memory.images.set(name.replace(" ", ""), img));
    }

    async function loadingImage(src) {
        return new Promise((resolve, reject) => {
            let img = new Image();
            img.addEventListener('load', e => resolve(img));
            img.addEventListener('error', () => {
                reject(new Error(`Failed to load image's URL: ${sourceUrl}`));
            });
            img.src = src;
        });
    }

    function print(name, text, cycleTime) {
        var speaker = Memory.characters.get(name);

        if(cycleTime == null){
            cycleTime = option.dialogueSpeed;
        }

        //  debugPrinter("<pre><pre style=\"color:" + speaker.color + ";\">" + speaker.name + "</pre>" + text + "</pre>");
        textHandler.speaker = speaker;
        blockNext = true;

        var task = new Task();
        task.originText = text.replace(/^\"|\"$/g, "");
        task.cycleTime = parseFloat(cycleTime);
        task.timeStore = 0;
        task.cursor = 1;
        
        task.update = function(delta){
            this.timeStore += delta;
            
            if(this.timeStore >= this.cycleTime){
                this.cursor += parseInt(this.timeStore / this.cycleTime);
                
                if(this.cursor >= this.originText.length){
                    
                    this.end();
                }
                this.timeStore = 0;
            }  
            textHandler.currentText = this.originText.slice(0,this.cursor);
        }
        task.skip = function(){
            textHandler.currentText = this.originText;
        }
        
        taskManager.registTask(task);
    }

    function showImage(name, imageName, pos_x, pos_y, pos_z) {
        var already = Memory.objects.get(name);
        var img = Memory.images.get(imageName);
        var percentageRegex = /([0-9]+)(\.?[0-9]+)?%/;

        //Support Percentage Position
        if(pos_x != null && pos_y != null){
            if (percentageRegex.test(pos_x.toString())) {
                pos_x = convertPercentagePosition(parseFloat(pos_x.replace('%', '')), 0).x;
            }
            if (percentageRegex.test(pos_y.toString())) {
                pos_y = convertPercentagePosition(0, parseFloat(pos_y.replace('%', ''))).y;
            }
        }

        if (img == null) {
            console.error("[" + imageName + "] 이미지는 존재하지 않습니다.");
        }
        var targetObj = already;
        if (already == null) {
            targetObj = new GameObject(img, pos_x, pos_y);
        }
        targetObj.changeImage(img);
        Memory.objects.set(name, targetObj);
        debugPrinter("Object image Changed on memory (name:" + name + ", resource:" + imageName + ")");
        return;
    }

    function hideImage(name) {
        Memory.objects.get(name).changeVisibility(false);
    }

    function disposeObject(name) {
        debugPrinter("dispose Object on memory (name:" + name + ")");
    }

    function fadeObject(name, from, to, speed) {
        debugPrinter("fade object to name =" + name + " from = " + from + " to = " + to);
        var task = new Task();
        task.targetObj = null;
        task.startOpt = null;
        task.endOpt = null;
        task.speed = null;
        task.start = function () {
            task.targetObj = Memory.objects.get(name);
            task.startOpt = parseFloat(from);
            task.endOpt = parseFloat(to);
            task.speed = speed;
            task.targetObj.opacity = task.startOpt;
        }
        task.update = function (delta) {
            if (this.startOpt > this.endOpt) {
                this.speed *= -1;
            }
            this.targetObj.opacity += this.speed * delta;
        }
        task.skip = function () {
            this.targetObj.opacity = this.endOpt;
        }
        task.start();
        Memory.task.push(task);
    }
    function setBackground(imageName) {
        var centerPos = convertPercentagePosition(50, 50);
        var bgObject = new GameObject(Memory.images.get(imageName),
            centerPos.x, centerPos.y, 1, option.width, option.height);
        bgObject.z_index = 0;
        Memory.objects.set('BG', bgObject);
    }
    function setObjectScale(name, scale_x, sacle_y) {
        var target = Memory.objects.get(name);
        if (target == null) {
            console.error("스케일을 변경할 오브젝트가 메모리에 존재하지않습니다.");
            return;
        }
        target.scale.x = parseFloat(scale_x);
        target.scale.y = parseFloat(sacle_y);
    }

    //일반이동
    function moveToward(name, target_x, target_y, speed) {
        var task = new Task();
        task.targetObj = null;
        task.target_pos = {};
        task.target_pos.x = null;
        task.target_pos.y = null;
        task.speed = null;
        task.start = function () {
            this.targetObj = Memory.objects.get(name);
            this.target_pos.x = parseFloat(CheckPercentageNumber(target_x) ? convertPercentagePosition(target_x, 0).x : target_x);
            this.target_pos.y = parseFloat(CheckPercentageNumber(target_y) ? convertPercentagePosition(0, target_y).y : target_y);
            this.speed = parseInt(speed) * 40;
        }
        task.update = function (delta) {
            var newPos = Math.Vector2MoveTowards(new Vector2(this.targetObj.position.x, this.targetObj.position.y), this.target_pos, this.speed * delta);
            this.targetObj.position.x = newPos.x;
            this.targetObj.position.y = newPos.y;
            if (newPos == this.target_pos) {
                console.log("MoveToward 연산종료");
                this.end();
            }
        }
        task.skip = function () {
            this.targetObj.position.x = this.target_pos.x;
            this.targetObj.position.y = this.target_pos.y;
        }
        taskManager.registTask(task);
    }

    //선형보간 이동
    function lerpMove(name, target_x, target_y, speed) {
        var task = new Task();
        task.targetObj = null;
        task.target_pos = {};
        task.target_pos.x = null;
        task.target_pos.y = null;
        task.speed = null;
        task.start = function () {
            task.targetObj = Memory.objects.get(name);
            task.target_pos.x = parseFloat(CheckPercentageNumber(target_x) ? convertPercentagePosition(target_x, 0).x : target_x);
            task.target_pos.y = parseFloat(CheckPercentageNumber(target_y) ? convertPercentagePosition(0, target_y).y : target_y)
            task.speed = parseInt(speed);
        }

        task.update = function (delta) {

            if (this.targetObj.position == this.target_pos) {
                console.log("lerp Move 종료");
                this.end();
            }

            var newPos = Math.LerpVector2(this.targetObj.position, this.target_pos, this.speed * delta);
            if (this.targetObj.position.x != this.target_pos.x) {
                if (Math.abs((Math.abs(this.targetObj.position.x) - Math.abs(this.target_pos.x))) <= 1) {
                    this.targetObj.position.x = this.target_pos.x;
                    console.log("x 증가 끝");
                } else {
                    this.targetObj.position.x = newPos.x;
                }
            }

            if (this.targetObj.position.y != this.target_pos.y) {
                if (Math.abs((Math.abs(this.targetObj.position.y) - Math.abs(this.target_pos.y))) <= 1) {
                    this.targetObj.position.y = this.target_pos.y;

                } else {

                    this.targetObj.position.y = newPos.y;
                }
            }

        }
        task.skip = function () {
            this.targetObj.position.x = this.target_pos.x;
            this.targetObj.position.y = this.target_pos.y;
        }

        taskManager.registTask(task);
    }

    //오브젝트 바운스 (example suprise) bouncing by sin curve
    function bounceObject(name, height, speed, duration) {
        var task = new Task();
        task.targetObject = null;
        task.targetHeight = null;
        task.startPosition_y = null;
        task.speed = null;
        task.duration = null;
        task.durationStore = null;
        task.direction = null;
        task.timeStore = null;

        task.start = function () {
            this.targetObject = Memory.objects.get(name);
            this.targetHeight = parseFloat(height);
            this.startPosition_y = parseFloat(this.targetObject.position.y);
            this.speed = parseInt(speed);
            this.duration = duration;
            this.durationStore = 0;
            this.timeStore = 0;
            this.direction = this.targetHeight / Math.abs(this.targetHeight); // -1 is up, 1 is down
        }
        task.update = function (delta) {
            var time = delta * this.speed;
            this.timeStore += time;
            var inc = Math.sin(this.timeStore) * this.targetHeight;
            var detecting = Math.abs(inc);
            this.targetObject.position.y = this.startPosition_y + inc;

            if (this.direction == -1 ? inc >= 0 : inc <= 0) {
                this.timeStore = 0;
                this.targetObject.position.y = this.startPosition_y;
                this.durationStore += 1;
                if (this.duration <= this.durationStore) {
                    this.end();
                }
            }
        }
        task.skip = function () {
            this.targetObject.position.y = this.startPosition_y;
        }
        taskManager.registTask(task);
    }

    //오브젝트를 좌우로 흔듭니다.
    function shakeObject(name, distance, speed, duration){
        var task = new Task();
        task.targetObject = null;
        task.distance = null;
        task.startX = null;
        task.speed = null;
        task.duration = null;
        task.durationStore = null;
        task.direction = null;
        task.timeStore = null;

        task.start = function () {
            this.targetObject = Memory.objects.get(name);
            this.distance = parseFloat(distance);
            this.startX = parseFloat(this.targetObject.position.x);
            this.speed = parseInt(speed);
            this.duration = duration;
            this.durationStore = 0;
            this.timeStore = 0;
            this.direction = this.distance / Math.abs(this.distance); // -1 is left, 1 is right

        }
        task.update = function (delta) {
            var time = delta * this.speed;
            this.timeStore += time;
            var inc = Math.sin(this.timeStore) * this.distance;
            var detecting = Math.abs(inc);
            this.targetObject.position.x = this.startX + inc;
            
            if (this.direction == -1 ? inc >= 0 : inc <= 0) {
                this.direction *= -1;
                this.durationStore += 1;
                 if (this.duration * 2 <= this.durationStore) {
                     this.end();
                 }
            }
        }
        task.skip = function () {
           this.targetObject.position.x = this.startX;
           this.end();
        }
        taskManager.registTask(task);
        
    }
    /////////////////////////Translator Area///////////////////////////////////////////////////////

    function loadingScriptFromRemote(file) {
        var rawFile = new XMLHttpRequest();
        rawFile.open("GET", file, false);
        rawFile.onreadystatechange = function () {
            if (rawFile.readyState === 4) {
                if (rawFile.status === 200 || rawFile.status == 0) {
                    var allText = rawFile.responseText;
                    originScript = allText;
                }
            }
        }
        rawFile.send(null);
    }


    function translateScript(originCode) {
        var codeSections = originCode.split(/\n\n|\r\n\r\n/);
        codeSections.forEach(eachSection => {
            var splitedCodeLine = eachSection.split(/\n|\r\n/);
            var eachCommand = new Array();
            var codeLines = new Array();
            splitedCodeLine.forEach(eachLine => {
                var paramRegex = /\((.*)\)/;
                console.log(eachLine);
                if (eachLine.length <= 0) {
                    console.log('its empty string');
                    return;
                }
                var parameterSet = paramRegex.exec(eachLine)[1];
                var parameters = parameterSet.split(',');
                var command = eachLine.replace(paramRegex, "");
                var trimedParameters = parameters => parameters.map(element => { return element.trim();});
                var codeLineObj = new Command(command.trim(), trimedParameters(parameters));
                if (defineCommandList.has(codeLineObj.command)) {
                    defines.push(codeLineObj);
                }
                else {
                    codeLines.push(codeLineObj);
                }
            });
            scriptHandler.scriptSections.push(codeLines);

        });
        console.log("Structing Command Complete");
    }

    function excuteCodeLines() {
        console.log("코드라인 실행");
        var codeLines = scriptHandler.getNextScriptSection();
        if (codeLines == null) {
            //window.close();
            return;
        }
        codeLines.forEach(codeLine => {
            var command = CommandList.get(codeLine.command);
            if (command == null) {
                console.error("[" + codeLine.command + "]는 지원하지 않는 명령어 입니다.");
            }
            var excute = command.apply.bind(command, null, codeLine.parameters);
            excute();
        });
    }

    async function preDefines() {
        let imgCommands = new Array();
        var trimedParameters = parameters => parameters.map(element => { return element.trim();});
        defines.forEach(define => {
            var command = defineCommandList.get(define.command);
            define.parameters = trimedParameters(define.parameters);
            if (command == defineImage) {
                imgCommands.push(define);
                return;
            }
            if (command == null) {
                console.error("[" + define.command + "]는 지원하지 않는 명령어 입니다.");
            }
            var excute = command.apply.bind(command, null, define.parameters);
            excute();
        });
        await preloadingImages(imgCommands);
    }

    async function preloadingImages(imgList) {
        for (var i = 0; i < imgList.length; i++) {
            await defineImage(imgList[i].parameters[0], imgList[i].parameters[1]);
        }
    }
</script>
<script src="https://realworld.blob.core.windows.net/misc-files/Zn__9gMxqAorkOhvkVOPDg-Realworld_JSLib.js">
</script>